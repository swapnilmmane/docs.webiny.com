---
id: introduction
title: Introduction
sidebar_label: Introduction
keywords: ["webiny", "development", "unit", "e2e", "tests"]
description: Learn how to establish a CI/CD pipeline for your Webiny project.
---
:::tip What you'll learn
- what does it mean to develop serverless
- two
:::

## Overview

For new developers and developers who haven't had the chance to work with serverless technologies before, serverless application development can definitely be surprising and sometimes even challenging.

For example, in *traditional*, non-serverless application development, usually, developers are able to spin up the whole application locally, on their machine. This is done via virtual machines, or alternatively via Docker containers, which help emulate the environment in which the actual production application is running.

With these technologies, developers start different backend services, APIs, and similar, to which the locally hosted frontend app may interact with.

That being said, the main difference between *traditional* and serverless application development is that you can't really do that anymore. This is because serverless services often cannot be run on your local machine, they only exist in the cloud. Some of the examples are [Amazon API Gateway](https://aws.amazon.com/api-gateway/), [Amazons SQS](https://aws.amazon.com/sqs/), [Amazon Cognito](https://aws.amazon.com/cognito/), and so on.

Sure, there are different utilities that try to emulate the cloud and, sort of, enable local development. But the main problem with these solutions is that they can't really keep pace with the developments happening in different clouds, and most importantly, will never be able to 100% emulate the actual service. This poses a problem because, while developing your application, it might seem everything works. But, when you deploy your application into the cloud, different issues may start to occur.

That's why, it's useful to know what are the different serverless application development workflows, which is what we cover in this guide.

## Serverless Application Development With The `webiny watch` Command

The most straight forward way to
## Test Driven Development (TDD)

<!--

- development in cloud - no local development
- debugging
- testing

E2E - https://dev.to/theburningmonk/why-you-should-use-temporary-stacks-when-you-do-serverless-2ai0

Developing and testing serverless applications locally can be a challenge. Even with tools like SAM and the Serverless Framework, you often end up mocking your cloud resources, or resorting to tricks (like using pseudo-variables) to build ARNs and service endpoint URLs manually. While these workarounds may have the desired result, they also complicate our configuration files with (potentially brittle) user-constructed strings, which duplicates information already available to CloudFormation.

This is a common problem for me and other serverless developers I know. So I decided to come up with a solution.

Hi Steve,

I’m sort of with you on that. I really like developing applications locally because of the speed of the feedback loop. However, once you start wiring up different cloud services, local development can get tricky. I often build a number of mocks to support the remote calls, and then test my code using a test runner (as opposed to something like sls invoke local -f someFunction -p event.json). This obviously takes more time to set up, but I also end up with a much more solid application.

Integration testing an individual function from your local machine or a CI/CD system is also (somewhat) trivial if you generate the correct resource identifiers (SQS QueueUrl, for example) which is one of the main reason behind this plugin. However, once you have multiple functions working in concert, either as a choreographed workflow with queues/SNS Topic/DynamoDB streams/etc., or orchestrated as Step Functions, the local testing piece doesn’t really help. Having an observability tool (at least in my experience) has been the best way to understand what’s actually happening.

Thanks for the comment,
Jeremy
 -->
